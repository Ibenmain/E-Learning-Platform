# SPDX-License-Identifier: MIT
"""
Classes Without Boilerplate
"""
from __future__ import annotations

from functools import partial
from typing import Callable

from . import converters
from . import exceptions
from . import filters
from . import setters
from . import validators
from ._cmp import cmp_using
from ._compat import Protocol
from ._config import get_run_validators
from ._config import set_run_validators
from ._funcs import asdict
from ._funcs import assoc
from ._funcs import astuple
from ._funcs import evolve
from ._funcs import has
from ._funcs import resolve_types
from ._make import attrib
from ._make import Attribute
from ._make import attrs
from ._make import Factory
from ._make import fields
from ._make import fields_dict
from ._make import make_class
from ._make import NOTHING
from ._make import validate
from ._next_gen import define
from ._next_gen import field
from ._next_gen import frozen
from ._next_gen import mutable
from ._version_info import VersionInfo


s = attributes = attrs
ib = attr = attrib
dataclass = partial(attrs, auto_attribs=True)  # happy Easter ;)


class AttrsInstance(Protocol):
    pass


__all__ = [
    'Attribute',
    'AttrsInstance',
    'Factory',
    'NOTHING',
    'asdict',
    'assoc',
    'astuple',
    'attr',
    'attrib',
    'attributes',
    'attrs',
    'cmp_using',
    'converters',
    'define',
    'evolve',
    'exceptions',
    'field',
    'fields',
    'fields_dict',
    'filters',
    'frozen',
    'get_run_validators',
    'has',
    'ib',
    'make_class',
    'mutable',
    'resolve_types',
    's',
    'set_run_validators',
    'setters',
    'validate',
    'validators',
]


def _make_getattr(mod_name: str) -> Callable:
    """
    Create a metadata proxy for packaging information that uses *mod_name* in
    its warnings and errors.
    """

    def __getattr__(name: str) -> str:
        dunder_to_metadata = {
            '__title__': 'Name',
            '__copyright__': '',
            '__version__': 'version',
            '__version_info__': 'version',
            '__description__': 'summary',
            '__uri__': '',
            '__url__': '',
            '__author__': '',
            '__email__': '',
            '__license__': 'license',
        }
        if name not in dunder_to_metadata:
            msg = f"module {mod_name} has no attribute {name}"
            raise AttributeError(msg)

        import sys
        import warnings

        from importlib.metadata import metadata

        if name not in ('__version__', '__version_info__'):
            warnings.warn(
                f"Accessing {mod_name}.{name} is deprecated and will be "
                'removed in a future release. Use importlib.metadata directly '
                "to query for attrs's packaging metadata.",
                DeprecationWarning,
                stacklevel=2,
            )

        meta = metadata('attrs')
        if name == '__license__':
            return 'MIT'
        if name == '__copyright__':
            return 'Copyright (c) 2015 Hynek Schlawack'
        if name in ('__uri__', '__url__'):
            return meta['Project-URL'].split(' ', 1)[-1]
        if name == '__version_info__':
            return VersionInfo._from_version_string(meta['version'])
        if name == '__author__':
            return meta['Author-email'].rsplit(' ', 1)[0]
        if name == '__email__':
            return meta['Author-email'].rsplit('<', 1)[1][:-1]

        return meta[dunder_to_metadata[name]]

    return __getattr__


__getattr__ = _make_getattr(__name__)
